const fs = require('fs');
const path = require('path');
const _ = require('underscore');
const counter = require('./counter');

var items = {};

// Public API - Fix these CRUD functions ///////////////////////////////////////

/* 2) Creating New To-Dos
The next step is to start saving new todos on the hard drive by refactoring create. Each new todo entry must be saved in its own file. Use the unique id generated by getNextUniqueId to create a file path inside the dataDir. Each time a POST request is made to the collection route, save a file with the todo item in this folder. Only save the todo text in the file, the id of the todo item is encoded into its filename -- DO NOT STORE AN OBJECT.
Commit your progress: "Complete creating new todos"

*/
exports.create = (text, callback) => {
  // If we invoke getNextUniqueId, counter.txt will increment
  // by one, the callback function is invoked with
  // parameters (err, stringCounter)
  // We can use stringCounter value as new todo file name
  // i.e. if stringCounter === '00001', then file will be '00001.txt'
  // invoker fs.writeFile with new file path, text argument, and callback(err, newTodo)?
  //

  counter.getNextUniqueId((err, counterString) => {
    var todo = {text: text, id: counterString};
    // console.log('todo.text:', todo.text);
    // console.log('id:', todo.id);
    counterString = counterString + '.txt';
    var filePath = path.join(exports.dataDir, counterString);
    // console.log('filePath: ', filePath, ' text: ', text);
    fs.writeFile(filePath, text, (err) => {
      // console.log(err, todo);
      if (err) {
        throw ('error writing file');
      } else {
        callback(null, todo);
      }
    });
  });





  // var id = counter.getNextUniqueId();
  // items[id] = text;
  // callback(null, { id, text });
};

/*
3) Retreiving all Todos
Next, refactor the readAll function by returning an array of todos to client app whenever a GET request to the collection route occurs. To do this, you will need to read the dataDir directory and build a list of files. Remember, the id of each todo item is encoded in its filename.

VERY IMPORTANT: at this point in the basic requirements, do not attempt to read the contents of each file that contains the todo item text. Failing to heed this instruction has the potential to send you down a rabbit hole.

Please note, however, you must still include a text field in your response to the client, and it's recommended that you use the message's id (that you identified from the filename) for both the id field and the text field. Doing so will have the effect of changing the presentation of your todo items for the time being; we'll address this issue shortly.

Commit your progress: "Complete retrieving all todos"

*/

exports.readAll = (callback) => {
  fs.readdir(exports.dataDir, (err, files) => {
    if (err) {
      throw ('error retrieving files');
    } else {
      var data = _.map(files, (id) => {
        id = id.slice(0, 5);
        return { id: id, text: id };
      });
      callback(null, data);
    }
  });
};

/* 4) Retrieving one Todo
Next, refactor the readOne to read a todo item from the dataDir based on the message's id. For this function, you must read the contents of the todo item file and respond with it to the client.

You'll know you've correctly written this function because when you click edit on the UI, you'll see the todo text in the popup window.

Commit your progress: "Complete retrieving one todo"
*/

exports.readOne = (id, callback) => {
  var text = items[id];
  if (!text) {
    callback(new Error(`No item with id: ${id}`));
  } else {
    callback(null, { id, text });
  }
};

/* 5) Updating a ToDO
Next, refactor the update function to rewrite the todo item stored in the dataDir based on its id.

You'll know this is working because you'll be able to save the edited todo item and upon subsequent clicks of the edit button, the changes will persist. You should also confirm the counter isn't changing between updates. Refreshing the page should also show the updated todo.

Commit your progress: "Complete updating a todo"
*/

exports.update = (id, text, callback) => {
  var item = items[id];
  if (!item) {
    callback(new Error(`No item with id: ${id}`));
  } else {
    items[id] = text;
    callback(null, { id, text });
  }
};

/* 6) Deleting a Todo
Lastly, refactor the delete function to remove the todo file stored in the dataDir based on the supplied id.

You'll know this is working because when you refresh the page, the delete todo item will no longer be present.

Commit your progress: "Complete deleting a todo"
*/

exports.delete = (id, callback) => {
  var item = items[id];
  delete items[id];
  if (!item) {
    // report an error if item not found
    callback(new Error(`No item with id: ${id}`));
  } else {
    callback();
  }
};

// Config+Initialization code -- DO NOT MODIFY /////////////////////////////////

exports.dataDir = path.join(__dirname, 'data');

exports.initialize = () => {
  if (!fs.existsSync(exports.dataDir)) {
    fs.mkdirSync(exports.dataDir);
  }
};


/* After Delete, then proceed to Promises... After Promises completed
Finish fixing readAll
At this point, it's time to circle back to finishing your work on readAll. You should first find the test for readAll and refactor it to expect the correct todo text instead of the id. Next, you'll need to refactor the function. Because each todo entry is stored in its own file, you'll end up with many async operations (n files = n async operations) that all need to complete before you can respond to the API request. This poses a significant challenge: your next task is to read up on promises to see how they can help you. (Hint, you'll very likely need to make use of Promise.all.)

Learn about promises by completing the 'Bare Minimum Requirements' of [Course] Promises. Then come back to this course and complete readAll.

Commit your progress: "Complete Bare Minimum Requirements"
*/